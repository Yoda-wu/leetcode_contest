## 力扣周赛记录


## 106周双周赛
### A 6461. 判断一个数是否迷人
给你一个三位数整数 n 。

如果经过以下修改得到的数字 恰好 包含数字 1 到 9 各一次且不包含任何 0 ，那么我们称数字 n 是 迷人的 ：

将 n 与数字 2 * n 和 3 * n 连接 。
如果 n 是迷人的，返回 true，否则返回 false 。

连接 两个数字表示把它们首尾相接连在一起。比方说 121 和 371 连接得到 121371 。

> 思路
> 
> 直接模拟，拼接n 2*n,3*n 转化成字符串数组ch 然后排序，遍历查看ch[i] 是否等于i+1

### B 6425. 找到最长的半重复子字符串

给你一个下标从 0 开始的字符串 s ，这个字符串只包含 0 到 9 的数字字符。

如果一个字符串 t 中至多有一对相邻字符是相等的，那么称这个字符串是 半重复的 。

请你返回 s 中最长 半重复 子字符串的长度。

一个 子字符串 是一个字符串中一段连续 非空 的字符。

> 思路


### C 6426. 移动机器人

有一些机器人分布在一条无限长的数轴上，他们初始坐标用一个下标从 0 开始的整数数组 nums 表示。当你给机器人下达命令时，它们以每秒钟一单位的速度开始移动。

给你一个字符串 s ，每个字符按顺序分别表示每个机器人移动的方向。'L' 表示机器人往左或者数轴的负方向移动，'R' 表示机器人往右或者数轴的正方向移动。

当两个机器人相撞时，它们开始沿着原本相反的方向移动。

请你返回指令重复执行 d 秒后，所有机器人之间两两距离之和。由于答案可能很大，请你将答案对 109 + 7 取余后返回。

注意：

对于坐标在 i 和 j 的两个机器人，(i,j) 和 (j,i) 视为相同的坐标对。也就是说，机器人视为无差别的。
当机器人相撞时，它们 立即改变 它们的前进时间，这个过程不消耗任何时间。
当两个机器人在同一时刻占据相同的位置时，就会相撞。

例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 2 并往左移动，下一秒，它们都将占据位置 1，并改变方向。再下一秒钟后，第一个机器人位于位置 0 并往左移动，而另一个机器人位于位置 2 并往右移动。

例如，如果一个机器人位于位置 0 并往右移动，另一个机器人位于位置 1 并往左移动，下一秒，第一个机器人位于位置 0 并往左行驶，而另一个机器人位于位置 1 并往右移动。

**关联题目： [1503. 所有蚂蚁掉下来前的最后一刻](https://leetcode.cn/problems/last-moment-before-all-ants-fall-out-of-a-plank/description/)**

> 思路
>
> 这道题的关键就是看`1503`这道题的结论，即改不改变方向都不影响最后机器人所在的坐标组成的数组。 知道这个结论就可以解决这道题的性能瓶颈
>
> 所以我们可以直接计算每个机器人最后的坐标（O(n)的时间复杂度）
>
> 最后再通过排序＋前缀和求两两之间的差值



## 349周赛

### A 6470. 既不是最小值也不是最大值
给你一个整数数组 nums ，数组由 不同正整数 组成，请你找出并返回数组中 任一 既不是 最小值 也不是 最大值 的数字，如果不存在这样的数字，返回 -1 。

返回所选整数。

> 思路
>
> 如果数组长度小于3，直接返回-1
> 排序，然后返回第二个元素即可。

### 6465. 执行子串操作后的字典序最小字符串

给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以完成以下行为：

选则 s 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，'b' 用 'a' 替换，'a' 用 'z' 替换。
返回执行上述操作 恰好一次 后可以获得的 字典序最小 的字符串。

子字符串 是字符串中的一个连续字符序列。

现有长度相同的两个字符串 x 和 字符串 y ，在满足 x[i] != y[i] 的第一个位置 i 上，如果  x[i] 在字母表中先于 y[i] 出现，则认为字符串 x 比字符串 y 字典序更小 。
 

> 思路
>
> 首先需要判断s中是否有a的前缀。如果有进行跳过`idx++`
>
> 然后从`idx`所在位置遍历s，如果没遇到a就行进行子串操作，如果遇到了a就停止。
>
> 最后返回结果即可。

### 6449. 收集巧克力
给你一个长度为 n 、下标从 0 开始的整数数组 nums ，表示收集不同巧克力的成本。每个巧克力都对应一个不同的类型，最初，位于下标 i 的巧克力就对应第 i 个类型。

在一步操作中，你可以用成本 x 执行下述行为：

同时对于所有下标 0 <= i < n - 1 进行以下操作， 将下标 i 处的巧克力的类型更改为下标 (i + 1) 处的巧克力对应的类型。如果 i == n - 1 ，则该巧克力的类型将会变更为下标 0 处巧克力对应的类型。
假设你可以执行任意次操作，请返回收集所有类型巧克力所需的最小成本。

> 思路
>
> 暴力枚举
>
> 用一个长为 n的数组 $\textit{sum}$ 统计操作 iii 次的总花费，这样就可以一边枚举子数组，一边求最小值，一边累加花费了。该方法只需要$\mathcal{O}(n)$ 的空间。



